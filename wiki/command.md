#### ``ICommand``

итак, нужна история обновлений игры  
она нужна в первую очередь для рефлексии некоторых компонентов над этими обновлениями –  
– и во вторую – для, разумеется, демок

самый распространённый метод хранения истории – через историю изменений объекта этой истории  
в общем-то, в случае monogame, изменения и обновления идут рука об руку

чтобы шагать по таймлайну игры взад и вперёд, эти изменения нужно уметь применять и откатывать, для чего есть паттерн команда

помимо информации о том, как изменять игру, нужно иметь информацию о том, когда это делать  
поэтому, в имеющиеся ``Do(...)`` и ``Undo(...)`` можно добавить ``gameTime`` из ``Update(gameTime)``  
это добавит возможность изменять компоненты частично в зависимости от времени проведения изменений и привязки их к определённой точке на истории

однако, не факт, что это нужно добавлять на все объекты команд, появляющиеся в программе  
возможно, достаточно какого-то одного глобального объекта, приводящего игру в движение

#### ``IScaleable``

в monogame-test-01 на компонентах планируется применять команды, иммитирующие постоянное применение каких-либо сил на этих компонентах  
поэтому, действие этих комманд должно масштабироваться в зависимости от того, как часто они выполняются  
таким образом, у них должна быть достигнута обратная пропорция между затраченным на выполнение временем и их силой

желательно иметь для таких комманд какой-то специальный интерфейс  
масштабируемые изменения можно представить в виде разницы, поэтому для ``IScaleable`` можно добавить ``Add(value)``, ``Subtract(value)``, ``Zerofy()`` и – для масштабирования этой разницы – ``Multiply(gameTime)``

таким образом, можно выбрать какое-либо отношение времени к силе для какой-либо команды.
